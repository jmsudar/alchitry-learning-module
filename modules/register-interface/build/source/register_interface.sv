/*
    This file was generated automatically by Alchitry Labs 2.0.36-BETA.
    Do not edit this file directly. Instead edit the original Lucid source.
    This is a temporary file and any changes made to it will be destroyed.
*/

module register_interface #(
        parameter CLK_FREQ = 27'h5f5e100
    ) (
        input wire clk,
        input wire rst,
        input wire [7:0] rx_data,
        input wire new_rx_data,
        output reg [7:0] tx_data,
        output reg new_tx_data,
        input wire tx_busy,
        output LucidGlobals::G_Register_request reg_out,
        input LucidGlobals::G_Register_response reg_in
    );
    localparam E_States_IDLE = 3'h0;
    localparam E_States_GET_ADDR = 3'h1;
    localparam E_States_WRITE = 3'h2;
    localparam E_States_REQUEST_WRITE = 3'h3;
    localparam E_States_REQUEST_READ = 3'h4;
    localparam E_States_WAIT_READ = 3'h5;
    localparam E_States_READ_RESULT = 3'h6;
    logic [2:0] D_state_d, D_state_q = 3'h0;
    logic [5:0] D_addr_ct_d, D_addr_ct_q = 0;
    logic [1:0] D_byte_ct_d, D_byte_ct_q = 0;
    logic D_inc_d, D_inc_q = 0;
    logic D_wr_d, D_wr_q = 0;
    logic [($clog2(CLK_FREQ / 3'h4))-1:0] D_timeout_d, D_timeout_q = 0;
    logic [31:0] D_addr_d, D_addr_q = 0;
    logic [31:0] D_data_d, D_data_q = 0;
    always @* begin
        D_timeout_d = D_timeout_q;
        D_byte_ct_d = D_byte_ct_q;
        D_wr_d = D_wr_q;
        D_inc_d = D_inc_q;
        D_addr_ct_d = D_addr_ct_q;
        D_state_d = D_state_q;
        D_addr_d = D_addr_q;
        D_data_d = D_data_q;
        
        reg_out.new_cmd = 1'h0;
        reg_out.write = 1'bx;
        reg_out.address = D_addr_q;
        reg_out.data = D_data_q;
        tx_data = 1'bx;
        new_tx_data = 1'h0;
        D_timeout_d = (($bits(D_timeout_q) > $bits(1'h1) ? $bits(D_timeout_q) : $bits(1'h1)) + 1)'(D_timeout_q + 1'h1);
        if (new_rx_data) begin
            D_timeout_d = 1'h0;
        end
        
        case (D_state_q)
            3'h0: begin
                D_timeout_d = 1'h0;
                D_byte_ct_d = 1'h0;
                if (new_rx_data) begin
                    D_wr_d = rx_data[3'h7];
                    D_inc_d = rx_data[3'h6];
                    D_addr_ct_d = rx_data[3'h5:1'h0];
                    D_state_d = 3'h1;
                end
            end
            3'h1: begin
                if (new_rx_data) begin
                    D_addr_d = {rx_data, D_addr_q[5'h1f-:5'h18]};
                    D_byte_ct_d = (($bits(D_byte_ct_q) > $bits(1'h1) ? $bits(D_byte_ct_q) : $bits(1'h1)) + 1)'(D_byte_ct_q + 1'h1);
                    if (D_byte_ct_q == 2'h3) begin
                        if (D_wr_q) begin
                            D_state_d = 3'h2;
                        end else begin
                            D_state_d = 3'h4;
                        end
                    end
                end
            end
            3'h2: begin
                if (new_rx_data) begin
                    D_data_d = {rx_data, D_data_q[5'h1f-:5'h18]};
                    D_byte_ct_d = (($bits(D_byte_ct_q) > $bits(1'h1) ? $bits(D_byte_ct_q) : $bits(1'h1)) + 1)'(D_byte_ct_q + 1'h1);
                    if (D_byte_ct_q == 2'h3) begin
                        D_state_d = 3'h3;
                    end
                end
            end
            3'h3: begin
                reg_out.new_cmd = 1'h1;
                reg_out.write = 1'h1;
                D_addr_ct_d = (($bits(D_addr_ct_q) > $bits(1'h1) ? $bits(D_addr_ct_q) : $bits(1'h1)) + 1)'(D_addr_ct_q - 1'h1);
                if (D_addr_ct_q == 1'h0) begin
                    D_state_d = 3'h0;
                end else begin
                    D_state_d = 3'h2;
                    if (D_inc_q) begin
                        D_addr_d = (($bits(D_addr_q) > $bits(1'h1) ? $bits(D_addr_q) : $bits(1'h1)) + 1)'(D_addr_q + 1'h1);
                    end
                end
            end
            3'h4: begin
                reg_out.new_cmd = 1'h1;
                reg_out.write = 1'h0;
                if (reg_in.drdy) begin
                    D_data_d = reg_in.data;
                    D_state_d = 3'h6;
                end else begin
                    D_state_d = 3'h5;
                end
            end
            3'h5: begin
                if (reg_in.drdy) begin
                    D_data_d = reg_in.data;
                    D_state_d = 3'h6;
                end
            end
            3'h6: begin
                D_timeout_d = 1'h0;
                if (!tx_busy) begin
                    tx_data = D_data_q[3'h7:1'h0];
                    D_data_d = D_data_q >> 4'h8;
                    new_tx_data = 1'h1;
                    D_byte_ct_d = (($bits(D_byte_ct_q) > $bits(1'h1) ? $bits(D_byte_ct_q) : $bits(1'h1)) + 1)'(D_byte_ct_q + 1'h1);
                    if (D_byte_ct_q == 2'h3) begin
                        D_addr_ct_d = (($bits(D_addr_ct_q) > $bits(1'h1) ? $bits(D_addr_ct_q) : $bits(1'h1)) + 1)'(D_addr_ct_q - 1'h1);
                        if (D_addr_ct_q == 1'h0) begin
                            D_state_d = 3'h0;
                        end else begin
                            D_state_d = 3'h4;
                            if (D_inc_q) begin
                                D_addr_d = (($bits(D_addr_q) > $bits(1'h1) ? $bits(D_addr_q) : $bits(1'h1)) + 1)'(D_addr_q + 1'h1);
                            end
                        end
                    end
                end
            end
        endcase
        if ((&D_timeout_q)) begin
            D_state_d = 3'h0;
        end
    end
    
    
    always @(posedge (clk)) begin
        if ((rst) == 1'b1) begin
            D_state_q <= 3'h0;
        end else begin
            D_state_q <= D_state_d;
        end
    end
    always @(posedge (clk)) begin
        D_addr_ct_q <= D_addr_ct_d;
        D_byte_ct_q <= D_byte_ct_d;
        D_inc_q <= D_inc_d;
        D_wr_q <= D_wr_d;
        D_timeout_q <= D_timeout_d;
        D_addr_q <= D_addr_d;
        D_data_q <= D_data_d;
        
    end
endmodule